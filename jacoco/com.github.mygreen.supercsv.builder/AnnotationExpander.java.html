<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnnotationExpander.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Super CSV Annotation</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.supercsv.builder</a> &gt; <span class="el_source">AnnotationExpander.java</span></div><h1>AnnotationExpander.java</h1><pre class="source lang-java linenums">package com.github.mygreen.supercsv.builder;

import java.lang.annotation.Annotation;
import java.lang.annotation.Repeatable;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.supercsv.exception.SuperCsvReflectionException;

import com.github.mygreen.supercsv.annotation.CsvComposition;
import com.github.mygreen.supercsv.annotation.CsvOverridesAttribute;
import com.github.mygreen.supercsv.annotation.constraint.CsvConstraint;
import com.github.mygreen.supercsv.annotation.constraint.CsvRequire;
import com.github.mygreen.supercsv.annotation.conversion.CsvConversion;
import com.github.mygreen.supercsv.exception.SuperCsvInvalidAnnotationException;
import com.github.mygreen.supercsv.localization.MessageBuilder;
import com.github.mygreen.supercsv.util.Utils;

/**
 * 繰り返しのアノテーション、合成のアノテーションを考慮して、アノテーションを展開します。
 * &lt;p&gt;並び順は、コンストラクタで指定されたものに並び変えられる。&lt;/p&gt;
 * 
 * &lt;p&gt;繰り返しのアノテーション{@link Repeatable}が付与されたアノテーションの場合、
 *    取得する際には複数のアノテーションがまとめたアノテーションとして別に取得されるため分解する。&lt;/p&gt;
 * 
 * &lt;p&gt;合成のアノテーション{@link CsvComposition}が付与されたアノテーションの場合、
 *    付与されているアノテーションに分解する。
 *    その際に、定義されている属性を元に、付与されているアノテーションの属性を上書きする。&lt;/p&gt;
 *
 * @since 2.0
 * @author T.TSUCHIE
 *
 */
public class AnnotationExpander {
    
    private final Comparator&lt;ExpandedAnnotation&gt; comparator;
    
    /**
     * アノテーションの並び順を指定するコンストラクタ。
     * 
     * @param annotationComparator アノテーションの並び順を指定するためのComparator。
     * @throws NullPointerException {@literal annotationComparator == null.}
     */
<span class="fc" id="L58">    public AnnotationExpander(final Comparator&lt;Annotation&gt; annotationComparator) {</span>
<span class="fc" id="L59">        Objects.requireNonNull(annotationComparator);</span>
        
<span class="fc" id="L61">        this.comparator = new Comparator&lt;ExpandedAnnotation&gt;() {</span>
            
            @Override
            public int compare(final ExpandedAnnotation o1, final ExpandedAnnotation o2) {
<span class="fc" id="L65">                return annotationComparator.compare(o1.getOriginal(), o2.getOriginal());</span>
            }
            
        };
<span class="fc" id="L69">    }</span>
    
    /**
     * 複数のアノテーションを展開する。
     * @param targetAnnos  展開対象のアノテーション
     * @return 展開されたアノテーション
     * @throws NullPointerException {@literal targetAnnos == null.}
     */
    public List&lt;ExpandedAnnotation&gt; expand(final Annotation[] targetAnnos) {
<span class="fc" id="L78">        Objects.requireNonNull(targetAnnos);</span>
        
<span class="fc" id="L80">        final List&lt;ExpandedAnnotation&gt; expanedList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        for(Annotation targetAnno : targetAnnos) {</span>
<span class="fc" id="L82">            expanedList.addAll(expand(targetAnno));</span>
        }
        
<span class="fc" id="L85">        Collections.sort(expanedList, comparator);</span>
        
<span class="fc" id="L87">        return expanedList;</span>
        
    }
    
    /**
     * アノテーションを展開する。
     * @param targetAnno 展開対象のアノテーション
     * @return 展開されたアノテーション
     * @throws NullPointerException {@literal targetAnno == null.}
     */
    public List&lt;ExpandedAnnotation&gt; expand(final Annotation targetAnno) {
<span class="fc" id="L98">        Objects.requireNonNull(targetAnno);</span>
        
<span class="fc" id="L100">        final List&lt;ExpandedAnnotation&gt; expandedList = new ArrayList&lt;&gt;();</span>
        
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if(isRepeated(targetAnno)) {</span>
            // 繰り返しのアノテーションの場合、要素を抽出する。
            try {
<span class="fc" id="L105">                final Method method = targetAnno.getClass().getMethod(&quot;value&quot;);</span>
<span class="fc" id="L106">                final Annotation[] annos = (Annotation[]) method.invoke(targetAnno);</span>
                
<span class="fc" id="L108">                int index = 0;</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">                for(Annotation anno : annos) {</span>
<span class="fc" id="L110">                    final List&lt;ExpandedAnnotation&gt; repeatedAnnos = expand(anno);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">                    for(ExpandedAnnotation repeatedAnno : repeatedAnnos) {</span>
<span class="fc" id="L112">                        repeatedAnno.setIndex(index);</span>
<span class="fc" id="L113">                    }</span>
                    
<span class="fc" id="L115">                    expandedList.addAll(repeatedAnnos);</span>
<span class="fc" id="L116">                    index++;</span>
                }
                
<span class="nc" id="L119">            } catch (Exception e) {</span>
<span class="nc" id="L120">                throw new RuntimeException(&quot;fail get repeated value attribute.&quot;, e);</span>
<span class="fc" id="L121">            }</span>
            
<span class="fc bfc" id="L123" title="All 2 branches covered.">        } else if(isComposed(targetAnno)) {</span>
<span class="fc" id="L124">            final ExpandedAnnotation composedAnno = new ExpandedAnnotation(targetAnno, true);</span>
            
            // 合成のアノテーションの場合、メタアノテーションを子供としてさらに抽出する。
<span class="fc" id="L127">            final List&lt;Annotation&gt; childAnnos = Arrays.asList(targetAnno.annotationType().getAnnotations());</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            for(Annotation anno : childAnnos) {</span>
                
<span class="fc" id="L130">                final List&lt;ExpandedAnnotation&gt; nestedAnnos = expand(anno).stream()</span>
<span class="fc" id="L131">                        .map(nestedAnno -&gt; overrideAttribute(targetAnno, nestedAnno))</span>
<span class="fc" id="L132">                        .collect(Collectors.toList());</span>
                
<span class="fc" id="L134">                composedAnno.addChilds(nestedAnnos);</span>
                
<span class="fc" id="L136">            }</span>
            
<span class="fc" id="L138">            Collections.sort(composedAnno.getChilds(), comparator);</span>
<span class="fc" id="L139">            expandedList.add(composedAnno);</span>
            
<span class="fc" id="L141">        } else {</span>
            // 通常のアノテーションの場合
<span class="fc" id="L143">            expandedList.add(new ExpandedAnnotation(targetAnno, false));</span>
            
        }
        
<span class="fc" id="L147">        Collections.sort(expandedList, comparator);</span>
<span class="fc" id="L148">        return expandedList;</span>
        
    }
    
    /**
     * 繰り返されたアノテーションかどうか判定する。
     * &lt;p&gt;属性「value」に、繰り返しのアノテーション{@link Repeatable}が付与されている
     *    アノテーションの配列を保持しているかどうかで判定する。&lt;/p&gt;
     * @param targetAnno
     * @return
     */
    private boolean isRepeated(final Annotation targetAnno) {
        
        try {
<span class="fc" id="L162">            final Method method = targetAnno.getClass().getMethod(&quot;value&quot;);</span>
            
            // 値のクラスタイプがアノテーションの配列かどうかのチェック
<span class="fc" id="L165">            final Class&lt;?&gt; returnType = method.getReturnType();</span>
<span class="fc bfc" id="L166" title="All 4 branches covered.">            if(!(returnType.isArray() &amp;&amp; Annotation.class.isAssignableFrom(returnType.getComponentType()))) {</span>
<span class="fc" id="L167">                return false;</span>
            }
            
<span class="fc" id="L170">            final Annotation[] annos = (Annotation[]) method.invoke(targetAnno);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            if(annos.length == 0) {</span>
<span class="nc" id="L172">                return false;</span>
            }
            
            // @Repetableアノテーションが付与されているかどうか
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">            if(annos[0].annotationType().getAnnotation(Repeatable.class) != null) {</span>
<span class="fc" id="L177">                return true;</span>
            }
            
<span class="fc" id="L180">        } catch (Exception e) {</span>
            
<span class="nc" id="L182">        }</span>
        
<span class="fc" id="L184">        return false;</span>
        
    }
    
    /**
     * 合成されたアノテーションかどうか判定する。
     * &lt;p&gt;メタアノテーション{@link CsvComposition}が付与されているかどうかで判定する。&lt;/p&gt;
     * @param targetAnno
     * @return
     */
    private boolean isComposed(final Annotation targetAnno) {
        
<span class="fc bfc" id="L196" title="All 2 branches covered.">        return targetAnno.annotationType().getAnnotation(CsvComposition.class) != null;</span>
        
    }
    
    /**
     * 合成したアノテーションの属性を、構成されるアノテーションに反映する。
     * @param compositionAnno 
     * @param nestedAnno
     * @return
     */
    private ExpandedAnnotation overrideAttribute(final Annotation compositionAnno, final ExpandedAnnotation nestedAnno) {
        
<span class="fc" id="L208">        final Annotation originalAnno = nestedAnno.getOriginal();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if(!isOverridableAnnotation(originalAnno)) {</span>
<span class="fc" id="L210">            return nestedAnno;</span>
        }
        
        // 上書きするアノテーションの属性の組み立て
<span class="fc" id="L214">        final Map&lt;String, Object&gt; overrideAttrs = buildOverrideAttribute(compositionAnno, nestedAnno);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        if(overrideAttrs.isEmpty()) {</span>
<span class="fc" id="L216">            return nestedAnno;</span>
        }
        
        // 既存のアノテーションの属性の作成
<span class="fc" id="L220">        final Class&lt;?&gt; annotationClass = originalAnno.annotationType();</span>
<span class="fc" id="L221">        final Map&lt;String, Object&gt; defaultValues = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for(Method method : annotationClass.getMethods()) {</span>
            try {
<span class="fc" id="L224">                method.setAccessible(true);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">                if(method.getParameterCount() == 0) {</span>
<span class="fc" id="L226">                    final Object value = method.invoke(originalAnno);</span>
<span class="fc" id="L227">                    defaultValues.put(method.getName(), value);</span>
                    
<span class="fc" id="L229">                } else {</span>
<span class="fc" id="L230">                    final Object value = method.getDefaultValue();</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                    if(value != null) {</span>
<span class="nc" id="L232">                        defaultValues.put(method.getName(), value);</span>
                    }
                    
                }
                
<span class="nc" id="L237">            } catch(IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {</span>
<span class="nc" id="L238">                throw new RuntimeException(String.format(&quot;fail get annotation attribute %s#%s.&quot;, annotationClass.getName(), method.getName()), e);</span>
<span class="fc" id="L239">            }</span>
        }
        
        // アノテーションのインスタンスの組み立てなおし
<span class="fc" id="L243">        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span>
<span class="fc" id="L244">        final Object annoObj = Proxy.newProxyInstance(classLoader, new Class[]{annotationClass},</span>
<span class="fc" id="L245">                new InvocationHandler() {</span>
                    
                    @Override
                    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {
<span class="fc" id="L249">                        final String name = method.getName();</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">                        if (name.equals(&quot;annotationType&quot;)) {</span>
<span class="fc" id="L251">                            return annotationClass;</span>
                            
<span class="fc bfc" id="L253" title="All 2 branches covered.">                        } else if(overrideAttrs.containsKey(name)){</span>
<span class="fc" id="L254">                            return overrideAttrs.get(name);</span>
                            
                        } else {
<span class="fc" id="L257">                            return defaultValues.get(name);</span>
                        }
                    }
        });
        
        // 値をコピーする
<span class="fc" id="L263">        final ExpandedAnnotation propagatedAnno = new ExpandedAnnotation((Annotation)annoObj, nestedAnno.isComposed());</span>
<span class="fc" id="L264">        propagatedAnno.setIndex(nestedAnno.getIndex());</span>
<span class="fc" id="L265">        propagatedAnno.addChilds(nestedAnno.getChilds());</span>
        
<span class="fc" id="L267">        return propagatedAnno;</span>
    }
    
    /**
     * アノテーションの属性を上書き可能かか判定する。
     * &lt;p&gt;ただし、実際には合成のアノテーションに属性がなければ上書きはされないので、あくまで上書き可能かの判定しか行わない。&lt;/p&gt;
     * &lt;p&gt;条件は以下の通り。&lt;/p&gt;
     * &lt;ul&gt;
     *  &lt;li&gt;メタアノテーション{@link CsvConstraint}、{@link CsvConversion}が付与されているアノテーションである。&lt;/li&gt;
     *  &lt;li&gt;アノテーション{@link CsvRequire}である。&lt;/li&gt;
     *  &lt;li&gt;フォーマット用のアノテーションである。パッケージ名から判定する。&lt;/li&gt;
     * &lt;/ul&gt;
     * @param targetAnno 判定対象のアノテーション
     * @return trueの場合、上書き対象。
     */
    private boolean isOverridableAnnotation(final Annotation targetAnno) {
        
<span class="fc" id="L284">        final Class&lt;?&gt; annoType = targetAnno.annotationType();</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if(annoType.getAnnotation(CsvConstraint.class) != null) {</span>
<span class="fc" id="L286">            return true;</span>
        }
        
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if(annoType.getAnnotation(CsvConversion.class) != null) {</span>
<span class="fc" id="L290">            return true;</span>
        }
        
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if(annoType.getTypeName().startsWith(&quot;com.github.mygreen.supercsv.annotation.format&quot;)) {</span>
<span class="nc" id="L294">            return true;</span>
        }
        
<span class="fc" id="L297">        return false;</span>
        
    }
    
    /**
     * 上書きする属性の組み立て
     * @param compositionAnno 合成のアノテーション
     * @param targetAnno 上書き対象のアノテーション
     * @return
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    private Map&lt;String, Object&gt; buildOverrideAttribute(final Annotation compositionAnno, final ExpandedAnnotation targetAnno) {
        
<span class="fc" id="L310">        final Annotation originalAnno = targetAnno.getOriginal();</span>
        
<span class="fc" id="L312">        final Map&lt;String, Object&gt; overrideAttrs = new HashMap&lt;&gt;();</span>
        
        // @CsvOvrerideAttributeが付与されたメソッド名
<span class="fc" id="L315">        final Set&lt;String&gt; overrideMethodNames = new HashSet&lt;&gt;();</span>
        
        // @CsvOverridesAttributeが付与された属性の組み立て
<span class="fc bfc" id="L318" title="All 2 branches covered.">        for(Method compositionMethod : compositionAnno.annotationType().getMethods()) {</span>
            
<span class="fc" id="L320">            final List&lt;CsvOverridesAttribute&gt; annoList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L321">            final CsvOverridesAttribute overrideAttrAnno = compositionMethod.getAnnotation(CsvOverridesAttribute.class);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">            if(overrideAttrAnno != null) {</span>
<span class="fc" id="L323">                annoList.add(overrideAttrAnno);</span>
            }
            
            // 繰り返しのアノテーションの場合
<span class="fc" id="L327">            final CsvOverridesAttribute.List overrideAttrAnnoList = compositionMethod.getAnnotation(CsvOverridesAttribute.List.class);</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">            if(overrideAttrAnnoList != null) {</span>
<span class="fc" id="L329">                annoList.addAll(Arrays.asList(overrideAttrAnnoList.value()));</span>
            }
            
<span class="fc bfc" id="L332" title="All 2 branches covered.">            if(annoList.isEmpty()) {</span>
                // @CsvOverridesAttributeが付与されていない場合
<span class="fc" id="L334">                continue;</span>
            }
            
<span class="fc" id="L337">            overrideMethodNames.add(compositionMethod.getName());</span>
            
<span class="fc bfc" id="L339" title="All 2 branches covered.">            for(CsvOverridesAttribute anno : annoList) {</span>
                // アノテーションのクラスの判定
<span class="fc bfc" id="L341" title="All 2 branches covered.">                if(!anno.annotation().equals(originalAnno.annotationType())) {</span>
<span class="fc" id="L342">                    continue;</span>
                }
                
                // インデックスの判定
<span class="fc bfc" id="L346" title="All 4 branches covered.">                if(anno.index() &gt;= 0 &amp;&amp; anno.index() != targetAnno.getIndex()) {</span>
<span class="fc" id="L347">                    continue;</span>
                }
                
<span class="fc bfc" id="L350" title="All 2 branches covered.">                final String attrName = anno.name().isEmpty() ? compositionMethod.getName() : anno.name();</span>
                
<span class="fc bfc" id="L352" title="All 2 branches covered.">                if(!Utils.hasAnnotationAttribute(originalAnno, attrName, compositionMethod.getReturnType())) {</span>
                    // 上書き対象の属性が見つからない場合
<span class="fc" id="L354">                    throw new SuperCsvInvalidAnnotationException(originalAnno, MessageBuilder.create(&quot;anno.CsvOverridesAnnotation.notFoundAttr&quot;)</span>
<span class="fc" id="L355">                            .varWithAnno(&quot;compositionAnno&quot;, compositionAnno.annotationType())</span>
<span class="fc" id="L356">                            .varWithAnno(&quot;overrideAnno&quot;, originalAnno.annotationType())</span>
<span class="fc" id="L357">                            .varWithClass(&quot;attrType&quot;, compositionMethod.getReturnType())</span>
<span class="fc" id="L358">                            .var(&quot;attrName&quot;, attrName)</span>
<span class="fc" id="L359">                            .format());</span>
                    
                }
                
                // 属性値の取得
                try {
<span class="fc" id="L365">                    Object attrValue = compositionMethod.invoke(compositionAnno);</span>
<span class="fc" id="L366">                    overrideAttrs.put(attrName, attrValue);</span>
                    
<span class="nc" id="L368">                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {</span>
<span class="nc" id="L369">                    throw new SuperCsvReflectionException(MessageBuilder.create(&quot;anno.CsvOverridesAnnotation.failGetAttr&quot;)</span>
<span class="nc" id="L370">                            .varWithAnno(&quot;compositionAnno&quot;, compositionAnno.annotationType())</span>
<span class="nc" id="L371">                            .var(&quot;attrName&quot;, attrName)</span>
<span class="nc" id="L372">                            .format(),</span>
                            e);
<span class="fc" id="L374">                }</span>
            
<span class="fc" id="L376">            }</span>
            
        }
        
        // message 属性の取得。
        // 既に取得していたり、@CsvOverridesAttributeが付与されている場合はスキップする。
<span class="fc bfc" id="L382" title="All 4 branches covered.">        if(!overrideAttrs.containsKey(&quot;message&quot;) &amp;&amp; !overrideMethodNames.contains(&quot;message&quot;)</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                &amp;&amp; Utils.hasAnnotationAttribute(originalAnno, &quot;message&quot;, String.class)) {</span>
            
<span class="fc" id="L385">            final Optional&lt;String&gt; messageAttr = Utils.getAnnotationAttribute(compositionAnno, &quot;message&quot;, String.class);</span>
<span class="pc bpc" id="L386" title="1 of 4 branches missed.">            if(messageAttr.isPresent() &amp;&amp; Utils.isNotEmpty(messageAttr.get())) {</span>
<span class="fc" id="L387">                overrideAttrs.put(&quot;message&quot;, messageAttr.get());</span>
            }
        }
        
        // groups 属性の取得。
        // 既に取得していたり、@CsvOverridesAttributeが付与されている場合はスキップする。
<span class="fc bfc" id="L393" title="All 4 branches covered.">        if(!overrideAttrs.containsKey(&quot;groups&quot;) &amp;&amp; !overrideMethodNames.contains(&quot;groups&quot;)</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">                &amp;&amp; Utils.hasAnnotationAttribute(originalAnno, &quot;groups&quot;, Class[].class)) {</span>
            
<span class="fc" id="L396">            final Optional&lt;Class[]&gt; groupsAttr = Utils.getAnnotationAttribute(compositionAnno, &quot;groups&quot;, Class[].class);</span>
<span class="fc bfc" id="L397" title="All 4 branches covered.">            if(groupsAttr.isPresent() &amp;&amp; Utils.isNotEmpty(groupsAttr.get())) {</span>
<span class="fc" id="L398">                overrideAttrs.put(&quot;groups&quot;, groupsAttr.get());</span>
            }
        }
        
        // cases 属性の取得。
        // 既に取得していたり、@CsvOverridesAttributeが付与されている場合はスキップする。
<span class="fc bfc" id="L404" title="All 4 branches covered.">        if(!overrideAttrs.containsKey(&quot;cases&quot;) &amp;&amp; !overrideMethodNames.contains(&quot;cases&quot;)</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">                &amp;&amp; Utils.hasAnnotationAttribute(originalAnno, &quot;cases&quot;, BuildCase[].class)) {</span>
            
<span class="fc" id="L407">            final Optional&lt;BuildCase[]&gt; casesAttr = Utils.getAnnotationAttribute(compositionAnno, &quot;cases&quot;, BuildCase[].class);</span>
<span class="pc bpc" id="L408" title="1 of 4 branches missed.">            if(casesAttr.isPresent() &amp;&amp; Utils.isNotEmpty(casesAttr.get())) {</span>
<span class="fc" id="L409">                overrideAttrs.put(&quot;cases&quot;, casesAttr.get());</span>
            }
        }
        
<span class="fc" id="L413">        return overrideAttrs;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>