<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Utils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Super CSV Annotation</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.supercsv.util</a> &gt; <span class="el_source">Utils.java</span></div><h1>Utils.java</h1><pre class="source lang-java linenums">package com.github.mygreen.supercsv.util;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;

import com.github.mygreen.supercsv.annotation.PatternFlag;
import com.github.mygreen.supercsv.builder.BuildCase;


/**
 * ユーティリティクラス。
 * 
 * @version 2.2
 * @author T.TSUCHIE
 *
 */
<span class="nc" id="L21">public class Utils {</span>
    
    /**
     * &lt;a href=&quot;http://www.joda.org/joda-time/&quot; target=&quot;_blank&quot;&gt;Joda-Time&lt;/a&gt;のライブラリが利用可能かどうか。
     */
    public static final boolean ENABLED_LIB_JODA_TIME;
    static {
        boolean enabled;
        try {
<span class="fc" id="L30">            Class.forName(&quot;org.joda.time.LocalDateTime&quot;);</span>
<span class="fc" id="L31">            enabled = true;</span>
<span class="nc" id="L32">        } catch(ClassNotFoundException e) {</span>
<span class="nc" id="L33">            enabled = false;</span>
<span class="fc" id="L34">        }</span>
<span class="fc" id="L35">        ENABLED_LIB_JODA_TIME = enabled;</span>
<span class="fc" id="L36">    }</span>
    
    /**
     * 文字列が空文字か判定する。
     * @param str
     * @return
     */
    public static boolean isEmpty(final String str) {
<span class="fc bfc" id="L44" title="All 4 branches covered.">        if(str == null || str.isEmpty()) {</span>
<span class="fc" id="L45">            return true;</span>
        }
        
<span class="fc bfc" id="L48" title="All 2 branches covered.">        if(str.length() == 1) {</span>
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">            return str.charAt(0) == '\u0000';</span>
        }
        
<span class="fc" id="L52">        return false;</span>
    }
    
    /**
     * 文字列が空文字でないか判定する。
     * @param str
     * @return
     */
    public static boolean isNotEmpty(final String str) {
<span class="fc bfc" id="L61" title="All 2 branches covered.">        return !isEmpty(str);</span>
    }
    
    /**
     * コレクションが空か判定する。
     * @param collection
     * @return nullまたはサイズが0のときにtrueを返す。
     */
    public static boolean isEmpty(final Collection&lt;?&gt; collection) {
<span class="nc bnc" id="L70" title="All 4 branches missed.">        if(collection == null || collection.isEmpty()) {</span>
<span class="nc" id="L71">            return true;</span>
        }
        
<span class="nc" id="L74">        return false;</span>
    }
    
    public static boolean isNotEmpty(final Collection&lt;?&gt; collection) {
<span class="nc bnc" id="L78" title="All 2 branches missed.">        return !isEmpty(collection);</span>
    }
    
    /**
     * 配列がが空か判定する。 
     * @param arrays
     * @return nullまたは、配列のサイズが0のときにtrueを返す。
     */
    public static boolean isEmpty(final Object[] arrays) {
<span class="pc bpc" id="L87" title="1 of 4 branches missed.">        if(arrays == null || arrays.length == 0) {</span>
<span class="fc" id="L88">            return true;</span>
        }
        
<span class="fc" id="L91">        return false;</span>
    }
    
    /**
     * 配列が空でないか判定する
     * @param arrays
     * @return
     */
    public static boolean isNotEmpty(final Object[] arrays) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        return !isEmpty(arrays);</span>
    }
    
    /**
     * 文字列形式のロケールをオブジェクトに変換する。
     * &lt;p&gt;アンダーバーで区切った'ja_JP'を分解して、Localeに渡す。
     * @since 1.2
     * @param str
     * @return 引数が空の時はデフォルトロケールを返す。
     */
    public static Locale getLocale(final String str) {
        
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if(isEmpty(str)) {</span>
<span class="fc" id="L113">            return Locale.getDefault();</span>
        }
        
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if(!str.contains(&quot;_&quot;)) {</span>
<span class="nc" id="L117">            return new Locale(str);</span>
        }
        
<span class="fc" id="L120">        final String[] split = str.split(&quot;_&quot;);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if(split.length == 2) {</span>
<span class="fc" id="L122">            return new Locale(split[0], split[1]);</span>
            
        } else {
<span class="fc" id="L125">            return new Locale(split[0], split[1], split[2]);</span>
        }
        
    }
    
    /**
     * アノテーションの指定した属性値を取得する。
     * &lt;p&gt;アノテーションの修飾子はpublicである必要があります。&lt;/p&gt;
     * @param anno アノテーションのインスタンス
     * @param attrName 属性名
     * @param attrType 属性のタイプ。
     * @return 属性を持たない場合、空を返す。
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Optional&lt;T&gt; getAnnotationAttribute(final Annotation anno, final String attrName, final Class&lt;T&gt; attrType) {
        
        try {
<span class="fc" id="L142">            final Method method = anno.annotationType().getMethod(attrName);</span>
<span class="fc" id="L143">            method.setAccessible(true);</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">            if(!attrType.equals(method.getReturnType())) {</span>
<span class="nc" id="L145">                return Optional.empty();</span>
            }
            
<span class="fc" id="L148">            final Object value = method.invoke(anno);</span>
<span class="fc" id="L149">            return Optional.of((T)value);</span>
            
<span class="fc" id="L151">        } catch (Exception e) {</span>
<span class="fc" id="L152">            return Optional.empty();</span>
        }
        
    }
    
    /**
     * アノテーションの指定した属性値を持つかどうか判定する。
     * &lt;p&gt;アノテーションの修飾子はpublicである必要があります。&lt;/p&gt;
     * @param anno アノテーションのインスタンス
     * @param attrName 属性名
     * @param attrType 属性のタイプ。
     * @return 属性を持つ場合trueを返す。
     */
    public static &lt;T&gt;  boolean hasAnnotationAttribute(final Annotation anno, final String attrName, final Class&lt;T&gt; attrType) {
        
<span class="fc" id="L167">        return getAnnotationAttribute(anno, attrName, attrType).isPresent();</span>
        
    }
    
    /**
     * アノテーションの属性「cases」を持つ場合、指定した種類を持つか判定する。
     * &lt;p&gt;属性「buildCase」を持たない場合、または、空の配列の場合は、必ずtrueを返します。&lt;/p&gt;
     * 
     * @param anno 判定対象のアノテーション。
     * @param buildCase 組み立てる種類。
     * @return trueの場合、指定した種類を含みます。
     * @throws NullPointerException anno or buildCase is null.
     */
    public static boolean containsBuildCase(final Annotation anno, final BuildCase buildCase) {
        
<span class="fc" id="L182">        Objects.requireNonNull(anno);</span>
<span class="fc" id="L183">        Objects.requireNonNull(buildCase);</span>
        
<span class="fc" id="L185">        final Optional&lt;BuildCase[]&gt; attrCases = getAnnotationAttribute(anno, &quot;cases&quot;, BuildCase[].class);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if(attrCases.isPresent()) {</span>
<span class="fc" id="L187">            final BuildCase[] casesValue = attrCases.get();</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">            if(casesValue.length == 0) {</span>
                // 値が空の配列の場合
<span class="fc" id="L190">                return true;</span>
            }
            
<span class="fc bfc" id="L193" title="All 2 branches covered.">            for(BuildCase value : casesValue) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">                if(value == buildCase) {</span>
<span class="fc" id="L195">                    return true;</span>
                }
            }
            
<span class="fc" id="L199">            return false;</span>
        }
        
        // 属性を持たない場合
<span class="fc" id="L203">        return true;</span>
    }
    
    /**
     * &lt;a href=&quot;http://www.joda.org/joda-time/&quot; target=&quot;_blank&quot;&gt;Joda-Time&lt;/a&gt;のライブラリが利用可能かどうか。
     * @return {@literal true}利用可能。
     */
    public static boolean isEnabledJodaTime() {
<span class="fc" id="L211">        return ENABLED_LIB_JODA_TIME;</span>
    }
    
    /**
     * プリミティブ型の初期値を取得する。
     * @param type プリミティブ型のクラス型。
     * @return 非プリミティブ型や該当するクラスがない場合はnullを返す。
     * @throws NullPointerException type is null.
     */
    public static Object getPrimitiveDefaultValue(final Class&lt;?&gt; type) {
        
<span class="fc" id="L222">        Objects.requireNonNull(type, &quot;type should not be null.&quot;);</span>
        
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if(!type.isPrimitive()) {</span>
<span class="fc" id="L225">            return null;</span>
            
<span class="fc bfc" id="L227" title="All 2 branches covered.">        } else if(boolean.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L228">            return false;</span>
            
<span class="fc bfc" id="L230" title="All 2 branches covered.">        } else if(char.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L231">            return '\u0000';</span>
            
<span class="fc bfc" id="L233" title="All 2 branches covered.">        } else if(byte.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L234">            return (byte)0;</span>
            
<span class="fc bfc" id="L236" title="All 2 branches covered.">        } else if(short.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L237">            return (short)0;</span>
            
<span class="fc bfc" id="L239" title="All 2 branches covered.">        } else if(int.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L240">            return 0;</span>
            
<span class="fc bfc" id="L242" title="All 2 branches covered.">        } else if(long.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L243">            return 0l;</span>
            
<span class="fc bfc" id="L245" title="All 2 branches covered.">        } else if(float.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L246">            return 0.0f;</span>
            
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        } else if(double.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L249">            return 0.0d;</span>
        }
        
<span class="nc" id="L252">        return null;</span>
        
    }
    
    /**
     * 文字列配列の結合
     * @param array1
     * @param array2
     * @return 結合した配列。引数のどちらからnullの場合は、cloneした配列を返します。
     */
    public static String[] concat(final String[] array1, final String[] array2) {
        
<span class="pc bpc" id="L264" title="1 of 4 branches missed.">        if(array1 == null || array1.length == 0) {</span>
<span class="fc" id="L265">            return clone(array2);</span>
            
<span class="pc bpc" id="L267" title="2 of 4 branches missed.">        } else if(array2 == null || array2.length == 0) {</span>
<span class="nc" id="L268">            return clone(array1);</span>
        }
        
<span class="fc" id="L271">        final String[] joinedArray = new String[array1.length + array2.length];</span>
<span class="fc" id="L272">        System.arraycopy(array1, 0, joinedArray, 0, array1.length);</span>
<span class="fc" id="L273">        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);</span>
<span class="fc" id="L274">        return joinedArray;</span>
        
    }
    
    /**
     * 文字列の配列をクローンします。
     * @since 2.2
     * @param array クローン対象の配列
     * @return クローンした配列。引数がnullの場合は、nullを返します。
     */
    public static String[] clone(final String[] array) {
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (array == null) {</span>
<span class="nc" id="L286">            return null;</span>
        }
<span class="fc" id="L288">        return array.clone();</span>
    }
    
    /**
     * コレクションを配列に変換する。
     * @param collection 変換対象のコレクション。
     * @return 変換した配列。
     * @throws NullPointerException collection is null.
     */
    public static int[] toArray(final Collection&lt;Integer&gt; collection) {
<span class="fc" id="L298">        Objects.requireNonNull(collection);</span>
        
<span class="fc" id="L300">        final int size = collection.size();</span>
<span class="fc" id="L301">        final int[] array = new int[size];</span>
        
<span class="fc" id="L303">        int i=0;</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">        for(Integer value : collection) {</span>
<span class="fc" id="L305">            array[i] = value;</span>
<span class="fc" id="L306">            i++;</span>
<span class="fc" id="L307">        }</span>
        
<span class="fc" id="L309">        return array;</span>
    }
    
    /**
     * 正規表現のフラグを組み立てる。
     * @param flags 正規表現の列挙型のフラグ
     * @return
     */
    public static int buildRegexFlags(final PatternFlag[] flags) {
        
<span class="fc" id="L319">        int intFlag = 0;</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        for(PatternFlag flag : flags) {</span>
<span class="fc" id="L321">            intFlag = intFlag | flag.getValue();</span>
        }
        
<span class="fc" id="L324">        return intFlag;</span>
        
    }
    
    /**
     * 先頭の文字を小文字にする。
     * @param str
     * @return 引数がnull、空文字の場合、そのまま返す。
     */
    public static String uncapitalize(final String str) {
        final int strLen;
<span class="nc bnc" id="L335" title="All 4 branches missed.">        if(str == null || (strLen = str.length()) == 0) {</span>
<span class="nc" id="L336">            return str;</span>
        }
        
<span class="nc" id="L339">        return new StringBuilder(strLen)</span>
<span class="nc" id="L340">            .append(String.valueOf(str.charAt(0)).toLowerCase())</span>
<span class="nc" id="L341">            .append(str.substring(1))</span>
<span class="nc" id="L342">            .toString();</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>